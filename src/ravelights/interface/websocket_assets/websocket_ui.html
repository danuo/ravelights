<!DOCTYPE html>
<html>
  <head>
    <title>three.js visualizer</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
  </head>
  <body>
    <div id="container"></div>
    <style>
      body,
      html {
        margin: 0;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
    <script
      src="https://cdn.socket.io/4.7.2/socket.io.min.js"
      crossorigin="anonymous"
    ></script>

    <script type="module">
      // three

      import * as THREE from "three";

      let scene, camera, renderer;

      function getRandomInt(max) {
        return Math.floor(Math.random() * max);
      }

      function linspace(start, end, num) {
        const step = (end - start) / (num - 1);
        const result = [];
        for (let i = 0; i < num; i++) {
          result.push(start + i * step);
        }
        return result;
      }

      const NLEDS = [20, 10, 10];
      const NLIGHTS = NLEDS.length;

      let sum = 0;
      // iterate over each item in the array
      for (let i = 0; i < NLEDS.length; i++) {
        sum += NLEDS[i];
      }
      const SIZE = sum;

      const data = new Uint8Array(4 * SIZE);
      function updateData() {
        for (let i = 0; i < SIZE; i++) {
          const stride = i * 4;
          data[stride] = 50;
          data[stride + 1] = 0;
          data[stride + 2] = getRandomInt(255);
          data[stride + 3] = 255;
        }
        for (let i = 0; i < 10; i++) {
          const stride = i * 4;
          data[stride] = 0;
          data[stride + 1] = 50;
          data[stride + 2] = 0;
          data[stride + 3] = 255;
        }
        data[0] = 255;
      }

      const texture = initTexture(data);

      function initTexture(data) {
        const texture = new THREE.DataTexture(data, 1, SIZE, THREE.RGBAFormat);
        texture.needsUpdate = true;

        // load a texture
        // const textureLoader = new THREE.TextureLoader();
        // const texture = textureLoader.load("uv-test-bw.jpg");
        return texture;
      }

      function initWebGL() {
        const container = document.getElementById("container");
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        camera = new THREE.Camera();

        // Create two PlaneGeometries

        // calculate spacings
        // input: NLEDS = [10, 10, 10];
        // output: [0, 1/3, 2/3, 3/3]
        let spacings = [0];
        let pixelCounter = 0;
        for (let i = 0; i < NLIGHTS; i++) {
          pixelCounter += NLEDS[i];
          spacings.push(pixelCounter / SIZE);
        }

        const planeWidth = (1 / NLIGHTS) * 1.3;
        const planeHeight = 1.8;
        const spread = 1 - planeWidth / 2 - 0.07;
        const positions = linspace(-spread, spread, NLIGHTS);

        for (let i = 0; i < NLIGHTS; i++) {
          let planeGeometry = new THREE.PlaneGeometry(
            planeWidth,
            planeHeight,
            1,
            1
          );
          let uvAttribute = planeGeometry.getAttribute("uv");
          const xStart = spacings[i];
          const xEnd = spacings[i + 1];
          // default
          // uvAttribute.setXY(0, 0, 1);
          // uvAttribute.setXY(1, 1, 1);
          // uvAttribute.setXY(2, 0, 0);
          // uvAttribute.setXY(3, 1, 0);

          // flipped with vars
          uvAttribute.setXY(0, 0, xStart);
          uvAttribute.setXY(1, 1, xStart);
          uvAttribute.setXY(2, 0, xEnd);
          uvAttribute.setXY(3, 1, xEnd);

          // planeGeometry.uvsNeedUpdate = true;
          let material = new THREE.MeshBasicMaterial({ map: texture });
          let mesh = new THREE.Mesh(planeGeometry, material);

          mesh.position.x = positions[i];
          scene.add(mesh);
        }

        window.addEventListener("resize", onWindowResize);
        animate();
      }

      function onWindowResize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        updateData();
        texture.needsUpdate = true;
        render();
      }

      function render() {
        renderer.render(scene, camera);
      }

      // websocket
      const apiUrl = "/rest/settings";
      async function fetchData() {
        const response = await fetch(apiUrl);
        if (response.status === 200) {
          const data = response.json();
          console.log(data);
          return data;
        }
        return null;
      }

      async function initWebsocket() {
        const data = await fetchData();
        const deviceConfig = data.device_config;
        console.log(deviceConfig);
        initWebGL();
        const socket = io();
        socket.on("message", (data) => {
          console.log("Received message: ", data);
        });
      }

      initWebsocket();

      // Call the async function to fetch the data
    </script>

    <script></script>
  </body>
</html>
